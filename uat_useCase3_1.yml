---
- name: Find MAC Address and Port for Given IP on Network Devices
  hosts: network_devices
  gather_facts: true
  connection: ansible.netcommon.network_cli
  become: yes
  become_method: ansible.netcommon.enable

  vars:
    ip_address: "{{ ip_address | default('') }}"  # From survey
    mac_address: "{{ mac_address | default('') }}"  # From survey
    device_location: "{{ device_location | default('office') }}"  # From survey
    template_mode: "{{ template_mode | default('template1') }}"  # Switch between template1 and template2
    vlan_id: "14"  # VLAN for MAC queries (configurable)
    email:
      smtp_server: "smtp.pccw.com"
      smtp_port: 25
      from_address: "osp-alertmgr@pccw.com"
      to_recipients: "kenny.wh.lo@pccw.com,mtam@redhat.com"
      subject: "UseCase3.1 Check Report - Template {{ '1' if template_mode == 'template1' else '2' }} - IP:{{ ip_address | default('N/A') }} MAC:{{ mac_address | default(target_mac | default('N/A')) }} Loc:{{ device_location }} - 2025-09-29T12:16:00+08:00"

  handlers:
    - name: Save configuration after port restart
      ignore_errors: yes
      ansible.netcommon.cli_command:
        command: "{{ 'write' if 'cisco.ios' in ansible_network_os else 'save force' if 'h3c_open.comware' in ansible_network_os or 'ce' in ansible_network_os else '' }}"
        prompt: "{{ '[HUAWEI]' if 'ce' in ansible_network_os else '[H3C]' if 'h3c_open.comware' in ansible_network_os else '' }}"
        timeout: 60

  tasks:
    - name: Set device-specific commands
      ansible.builtin.set_fact:
        ip_command: "{{ 'show ip interface brief' if 'cisco.ios' in ansible_network_os else 'display ip interface brief' }}"
        arp_command: "{{ 'show arp' if 'cisco.ios' in ansible_network_os else 'display arp vlan ' + vlan_id if 'h3c_open.comware' in ansible_network_os else 'display arp' }}"
        ping_command: "{{ 'ping ' + ip_address if 'cisco.ios' in ansible_network_os else 'ping -c 1 ' + ip_address }}"
        mac_command: "{{ 'show mac address-table' if 'cisco.ios' in ansible_network_os else 'display mac-address' }}"

    - name: Set pagination disable command
      ansible.builtin.set_fact:
        pagination_cmd: "{{ 'terminal length 0' if 'cisco.ios' in ansible_network_os else 'screen-length disable' if 'h3c_open.comware' in ansible_network_os else 'screen-length 0 temporary' if 'ce' in ansible_network_os else '' }}"

    - name: DEBUG - Show determined commands
      ansible.builtin.debug:
        msg:
          - "IP command: {{ ip_command }}"
          - "ARP command: {{ arp_command }}"
          - "Ping command: {{ ping_command }}"
          - "MAC command: {{ mac_command }}"
          - "Pagination command: {{ pagination_cmd }}"

    - name: Disable pagination on devices
      ansible.netcommon.cli_command:
        command: "{{ pagination_cmd }}"
      when: pagination_cmd != ''
      ignore_errors: yes
      ignore_unreachable: yes

    - name: Ping the IP to populate ARP and MAC tables
      ansible.netcommon.cli_command:
        command: "{{ ping_command }}"
      register: ping_output
      ignore_errors: yes
      ignore_unreachable: yes
      when: ip_address != ''
      changed_when: false
      timeout: 30

    - name: DEBUG - Show ping output
      ansible.builtin.debug:
        var: ping_output.stdout_lines
      when: ping_output.stdout_lines is defined

    - name: Run command to get ARP details
      ansible.netcommon.cli_command:
        command: "{{ arp_command }}"
      register: arp_output
      when: ip_address != '' and mac_address == ''
      changed_when: false
      timeout: "{{ 60 if 'h3c_open.comware' in ansible_network_os else 30 }}"
      ignore_unreachable: yes
      ignore_errors: yes

    - name: DEBUG - Show raw ARP command output
      ansible.builtin.debug:
        var: arp_output.stdout_lines
      when: ip_address != '' and mac_address == '' and arp_output.stdout_lines is defined

    - name: DEBUG - Log ARP command failure
      ansible.builtin.debug:
        msg: "ARP command failed on {{ inventory_hostname }}: {{ arp_output.msg | default('No error message') }}"
      when: ip_address != '' and mac_address == '' and arp_output.failed | default(false)

    - name: Fallback ARP command for H3C if initial ARP fails
      ansible.netcommon.cli_command:
        command: "display arp"
      register: arp_output_fallback
      when: ip_address != '' and mac_address == '' and arp_output.failed | default(false) and 'h3c_open.comware' in ansible_network_os
      changed_when: false
      timeout: 60
      ignore_unreachable: yes
      ignore_errors: yes

    - name: DEBUG - Show fallback ARP command output
      ansible.builtin.debug:
        var: arp_output_fallback.stdout_lines
      when: arp_output_fallback.stdout_lines is defined

    - name: Combine ARP output
      ansible.builtin.set_fact:
        arp_output_combined: "{{ arp_output.stdout_lines if arp_output.stdout_lines is defined and not arp_output.failed | default(false) else arp_output_fallback.stdout_lines | default([]) }}"
      when: ip_address != '' and mac_address == ''

    - name: Find ARP entry for the given IP
      ansible.builtin.set_fact:
        arp_line: "{{ arp_output_combined | select('search', ip_address) | list }}"
      when: ip_address != '' and mac_address == '' and arp_output_combined is defined

    - name: Extract MAC address from ARP entry
      ansible.builtin.set_fact:
        found_mac: "{{ arp_line[0] | regex_search('([0-9a-fA-F]{4}[\\.-][0-9a-fA-F]{4}[\\.-][0-9a-fA-F]{4})') | default('Not found') }}"
      when: ip_address != '' and mac_address == '' and arp_line is defined and arp_line | length > 0

    - name: Extract port from ARP entry for Huawei
      ansible.builtin.set_fact:
        arp_port: "{{ arp_line[0].split()[4] if 'ce' in ansible_network_os and arp_line[0].split() | length > 4 else 'Not found' }}"
      when: ip_address != '' and mac_address == '' and arp_line is defined and arp_line | length > 0 and 'ce' in ansible_network_os

    - name: Set target MAC (use provided or found)
      ansible.builtin.set_fact:
        target_mac: "{{ mac_address if mac_address != '' else found_mac | default('Not found') }}"

    - name: Normalize MAC for device-specific query format
      ansible.builtin.set_fact:
        query_mac: >-
          {{
            (target_mac | lower | replace('-', '.')) if 'cisco.ios' in ansible_network_os else
            (target_mac | lower | replace('.', '-')) if 'ce' in ansible_network_os or 'h3c_open.comware' in ansible_network_os else
            target_mac | lower
          }}
      when: target_mac != 'Not found'

    - name: DEBUG - Show target MAC
      ansible.builtin.debug:
        msg: "Target MAC: {{ target_mac }} at location {{ device_location }}"

    - name: DEBUG - Show normalized query MAC
      ansible.builtin.debug:
        msg: "Query MAC for {{ inventory_hostname }}: {{ query_mac | default('N/A') }}"
      when: target_mac != 'Not found'

    - name: Query MAC address table when MAC available
      ansible.netcommon.cli_command:
        command: "{{ mac_command }} {{ 'vlan ' + vlan_id if 'ce' in ansible_network_os or 'h3c_open.comware' in ansible_network_os else '' }} | include {{ query_mac | default(target_mac) }}"
      register: mac_table
      when: target_mac != 'Not found'
      changed_when: false
      timeout: 30
      ignore_unreachable: yes

    - name: DEBUG - Show raw MAC table output
      ansible.builtin.debug:
        var: mac_table.stdout_lines
      when: mac_table.stdout_lines is defined

    - name: Fallback MAC address table query for Huawei
      ansible.netcommon.cli_command:
        command: "{{ mac_command }} vlan {{ vlan_id }}"
      register: mac_table_fallback
      when: target_mac != 'Not found' and (mac_table.stdout_lines | select('search', query_mac | default(target_mac)) | list | length == 0) and 'ce' in ansible_network_os
      changed_when: false
      timeout: 30
      ignore_unreachable: yes

    - name: DEBUG - Show fallback MAC table output
      ansible.builtin.debug:
        var: mac_table_fallback.stdout_lines
      when: mac_table_fallback.stdout_lines is defined

    - name: Combine MAC table results
      ansible.builtin.set_fact:
        mac_table_combined: "{{ 
          mac_table.stdout_lines if (mac_table.stdout_lines | select('search', query_mac | default(target_mac)) | list | length > 0) else 
          mac_table_fallback.stdout_lines | default([]) 
        }}"
      when: target_mac != 'Not found'

    - name: Find MAC table entry line (filters out headers)
      ansible.builtin.set_fact:
        mac_line: "{{ mac_table_combined | select('search', query_mac | default(target_mac)) | list | default([]) }}"
      when: target_mac != 'Not found'

    - name: Debug full MAC address table for Huawei
      ansible.netcommon.cli_command:
        command: "{{ mac_command }}"
      register: full_mac_table
      when: target_mac != 'Not found' and mac_line | length == 0 and 'ce' in ansible_network_os
      changed_when: false
      timeout: 30
      ignore_unreachable: yes

    - name: DEBUG - Show full MAC table for Huawei
      ansible.builtin.debug:
        var: full_mac_table.stdout_lines
      when: full_mac_table.stdout_lines is defined

    - name: Initialize port_data for all hosts
      ansible.builtin.set_fact:
        port_data: "{{ hostvars[inventory_hostname].get('port_data', []) | default([]) }}"
        cacheable: yes

    - name: Extract port from MAC table entry
      ansible.builtin.set_fact:
        found_port: "{{ 
          mac_line[0].split()[-1] if 'cisco.ios' in ansible_network_os and mac_line | length > 0 else 
          mac_line[0].split()[3] if 'h3c_open.comware' in ansible_network_os and mac_line | length > 0 else 
          mac_line[0].split()[2] if 'ce' in ansible_network_os and mac_line | length > 0 else 
          arp_port | default('Not found') if 'ce' in ansible_network_os else 
          'Not found' 
        }}"
      when: mac_line is defined and (mac_line | length > 0 or ('ce' in ansible_network_os and arp_port is defined and arp_port != 'Not found'))

    - name: Set default found_port if not extracted
      ansible.builtin.set_fact:
        found_port: "{{ found_port | default('Not found') }}"

    - name: DEBUG - Show extracted port
      ansible.builtin.debug:
        msg: "Extracted port: {{ found_port }} for MAC {{ query_mac | default(target_mac) }} on {{ inventory_hostname }}"
      when: target_mac != 'Not found'

    - name: Check port type when port is found
      ansible.netcommon.cli_command:
        command: "{{ 
          'show interfaces ' + found_port + ' switchport' if 'cisco.ios' in ansible_network_os else 
          'display interface ' + found_port + ' brief' if 'h3c_open.comware' in ansible_network_os else 
          'display port vlan' if 'ce' in ansible_network_os else 
          ''
        }}"
      register: port_output
      ignore_errors: yes
      failed_when: false
      when: found_port != 'Not found'
      timeout: 30
      ignore_unreachable: yes

    - name: Fallback port type query for Huawei
      ansible.netcommon.cli_command:
        command: "display port vlan"
      register: port_output_fallback
      ignore_errors: yes
      failed_when: false
      when: found_port != 'Not found' and 'ce' in ansible_network_os and (port_output.stdout_lines is not defined or port_output.stdout_lines | length == 0)
      timeout: 30
      ignore_unreachable: yes

    - name: Combine port type output
      ansible.builtin.set_fact:
        port_output_combined: "{{ 
          port_output.stdout_lines if port_output.stdout_lines is defined and port_output.stdout_lines | length > 0 else 
          port_output_fallback.stdout_lines | default([]) 
        }}"
      when: found_port != 'Not found'

    - name: DEBUG - Show port type output
      ansible.builtin.debug:
        var: port_output_combined
      when: found_port != 'Not found' and port_output_combined is defined

    - name: Parse port type accurately
      ansible.builtin.set_fact:
        port_type: "{{ 
          'trunk' if (port_output.stdout is defined and port_output.stdout | regex_search('Administrative Mode:\\s*trunk')) else 
          'access' if (port_output.stdout is defined and port_output.stdout | regex_search('Administrative Mode:\\s*static access')) else 
          'unknown' if 'cisco.ios' in ansible_network_os else 
          ({'a': 'access', 't': 'trunk', 'h': 'hybrid'}.get(port_line.split()[4].lower(), 'unknown')) if 'h3c_open.comware' in ansible_network_os and port_line and port_line.split() | length > 4 else 
          ({'access': 'access', 'trunk': 'trunk', 'hybrid': 'hybrid'}.get(port_line.split()[1].lower(), 'unknown')) if 'ce' in ansible_network_os and port_line and port_line.split() | length > 1 else 
          'unknown' 
        }}"
      vars:
        port_line: "{{ port_output_combined | select('search', found_port) | first | default('') }}"
      when: found_port != 'Not found' and port_output_combined is defined

    - name: Set default port type if not parsed
      ansible.builtin.set_fact:
        port_type: "{{ port_type | default('unknown') }}"
      when: found_port != 'Not found'

    - name: DEBUG - Log port type parsing failure
      ansible.builtin.debug:
        msg: "Failed to parse port type for {{ found_port }} on {{ inventory_hostname }}: port_line={{ port_line | default('empty') }}"
      when: found_port != 'Not found' and port_type == 'unknown'

    - name: Log port type (access or trunk)
      ansible.builtin.debug:
        msg: "Port {{ found_port }} on {{ inventory_hostname }} at {{ device_location }} is {{ port_type }}"
      when: found_port != 'Not found' and port_type != 'unknown'

    - name: Collect port data for global aggregation
      ansible.builtin.set_fact:
        port_data: "{{ hostvars[inventory_hostname].get('port_data', []) | default([]) + [{'hostname': inventory_hostname, 'port': found_port, 'type': port_type | default('unknown')}] }}"
        cacheable: yes
      when: found_port != 'Not found'

    - name: Aggregate access ports across all devices
      ansible.builtin.set_fact:
        access_ports: "{{ 
          (groups['network_devices'] | map('extract', hostvars, 'port_data') | select('defined') | flatten | selectattr('type', 'equalto', 'access') | list) | default([]) 
        }}"
      when: template_mode == 'template2'
      delegate_to: localhost

    - name: Set config command for port restart for Cisco
      ansible.builtin.set_fact:
        config_command_cisco: "{{ ['interface ' + found_port, 'shutdown', 'no shutdown'] }}"
      when: found_port != 'Not found' and template_mode == 'template2' and 'cisco.ios' in ansible_network_os

    - name: Set config command for port restart for H3C
      ansible.builtin.set_fact:
        config_command_h3c: "{{ ['system-view', 'interface ' + found_port, 'shutdown', 'undo shutdown', 'quit'] }}"
      when: found_port != 'Not found' and template_mode == 'template2' and 'h3c_open.comware' in ansible_network_os

    - name: Set config command for port restart for Huawei
      ansible.builtin.set_fact:
        config_command_huawei: "{{ ['system-view', 'interface ' + found_port, 'shutdown', 'undo shutdown', 'return', 'commit', 'quit'] }}"
      when: found_port != 'Not found' and template_mode == 'template2' and 'ce' in ansible_network_os

    - name: Debug config command content for Cisco
      ansible.builtin.debug:
        msg: "Config commands for {{ inventory_hostname }}: {{ config_command_cisco }}"
      when: config_command_cisco is defined

    - name: Debug config command content for H3C
      ansible.builtin.debug:
        msg: "Config commands for {{ inventory_hostname }}: {{ config_command_h3c }}"
      when: config_command_h3c is defined

    - name: Debug config command content for Huawei
      ansible.builtin.debug:
        msg: "Config commands for {{ inventory_hostname }}: {{ config_command_huawei }}"
      when: config_command_huawei is defined

    - name: Apply port restart for Cisco if not trunk (Template 2)
      ansible.netcommon.cli_command:
        command: "{{ item }}"
      loop: "{{ config_command_cisco }}"
      when: "found_port != 'Not found' and port_type == 'access' and template_mode == 'template2' and 'cisco.ios' in ansible_network_os and access_ports | length == 1"
      register: config_result_cisco
      ignore_errors: yes
      ignore_unreachable: yes
      failed_when: false
      changed_when: "'shutdown' in item or 'no shutdown' in item"
      notify: Save configuration after port restart

    - name: Apply port restart for H3C if not trunk (Template 2)
      ansible.netcommon.cli_command:
        command: "{{ item }}"
      loop: "{{ config_command_h3c }}"
      when: "found_port != 'Not found' and port_type == 'access' and template_mode == 'template2' and 'h3c_open.comware' in ansible_network_os and access_ports | length == 1"
      register: config_result_h3c
      ignore_errors: yes
      ignore_unreachable: yes
      failed_when: false
      changed_when: "'shutdown' in item or 'undo shutdown' in item"
      notify: Save configuration after port restart

    - name: Apply port restart for Huawei if not trunk (Template 2)
      ansible.netcommon.cli_command:
        command: "{{ item }}"
      loop: "{{ config_command_huawei }}"
      when: "found_port != 'Not found' and port_type == 'access' and template_mode == 'template2' and 'ce' in ansible_network_os and access_ports | length == 1"
      register: config_result_huawei
      ignore_errors: yes
      ignore_unreachable: yes
      failed_when: false
      changed_when: "'shutdown' in item or 'undo shutdown' in item"
      notify: Save configuration after port restart

    - name: Store config result for email
      ansible.builtin.set_fact:
        config_results: "{{ hostvars[inventory_hostname].get('config_results', []) | default([]) + [
          {'hostname': inventory_hostname, 'result': config_result_cisco} if 'cisco.ios' in ansible_network_os and config_result_cisco is defined else
          {'hostname': inventory_hostname, 'result': config_result_h3c} if 'h3c_open.comware' in ansible_network_os and config_result_h3c is defined else
          {'hostname': inventory_hostname, 'result': config_result_huawei} if 'ce' in ansible_network_os and config_result_huawei is defined else
          {}
        ] }}"
        cacheable: yes

    - name: DEBUG - Show configuration result
      ansible.builtin.debug:
        var: "{{ 'config_result_cisco' if 'cisco.ios' in ansible_network_os and config_result_cisco is defined else 'config_result_h3c' if 'h3c_open.comware' in ansible_network_os and config_result_h3c is defined else 'config_result_huawei' if 'ce' in ansible_network_os and config_result_huawei is defined else 'config_result' }}"
      when: config_result_cisco is defined or config_result_h3c is defined or config_result_huawei is defined

    - name: Save configuration after port restart
      ansible.netcommon.cli_command:
        command: "{{ 'write' if 'cisco.ios' in ansible_network_os else 'save force' if 'h3c_open.comware' in ansible_network_os or 'ce' in ansible_network_os else '' }}"
        delay: 2
      when:
        - found_port != 'Not found'
        - port_type == 'access'
        - template_mode == 'template2'
        - access_ports | length == 1
        - (config_result_cisco is defined and not (config_result_cisco.results | select('failed') | list | length > 0)) or
          (config_result_h3c is defined and not (config_result_h3c.results | select('failed') | list | length > 0)) or
          (config_result_huawei is defined and not (config_result_huawei.results | select('failed') | list | length > 0))
      ignore_errors: yes
      ignore_unreachable: yes
      timeout: 60

    - name: Collect device data for email
      ansible.builtin.set_fact:
        device_data: "{{ hostvars[inventory_hostname].get('device_data', []) | default([]) + [{'hostname': inventory_hostname, 'port': found_port, 'port_type': port_type | default('unknown')}] }}"
        cacheable: yes

    - name: Send email notification (Template 1)
      ansible.builtin.mail:
        host: "{{ email.smtp_server }}"
        port: "{{ email.smtp_port }}"
        sender: "{{ email.from_address }}"
        to: "{{ email.to_recipients }}"
        subject: "{{ email.subject }}"
        body: |
          IP: {{ ip_address | default('N/A') }}
          MAC: {{ target_mac | default('N/A') }}
          Location: {{ device_location }}
          {% set access_ports = groups['network_devices'] | map('extract', hostvars, 'device_data') | select('defined') | flatten | selectattr('port_type', 'equalto', 'access') | list %}
          Summary: {% if access_ports | length == 1 %}
          One access port found on device: {{ access_ports[0].hostname }}, port: {{ access_ports[0].port }}. (restart will be applied in template 2)
          {% else %}
          {% set found_ports = groups['network_devices'] | map('extract', hostvars, 'device_data') | select('defined') | flatten | selectattr('port', 'ne', 'Not found') | list %}
          {% if found_ports | length == 0 %}
          Port not found on all devices.
          {% else %}
          No single access port found ({{ access_ports | length }} access ports found).
          {% endif %}
          {% endif %}

          {% for device in groups['network_devices'] %}
          {% set dev_data = hostvars[device].device_data | default([]) | selectattr('hostname', 'equalto', device) | first | default({}) %}
          {% if dev_data.port | default('Not found') == 'Not found' %}
          Device: {{ device }}
          IP: {{ ip_address | default('N/A') }}
          MAC Address: {{ target_mac | default('N/A') }}
          Note: Port not found on this device.
          {% else %}
          Device: {{ device }}
          Location: {{ device_location }}
          MAC Address: {{ target_mac | default('N/A') }}
          Port: {{ dev_data.port | default('Not found') }}
          Port Type: {{ dev_data.port_type | default('unknown') }}
          Note: {% if dev_data.port_type | default('unknown') == 'access' %}
          Access port by IP / MAC located in this port (restart will be applied in template 2)
          {% else %}
          Port is not an access port; no restart will be applied in template 2.
          {% endif %}
          {% endif %}
          {% endfor %}
      run_once: true
      delegate_to: localhost
      when: template_mode == 'template1'

    - name: Send email notification (Template 2)
      ansible.builtin.mail:
        host: "{{ email.smtp_server }}"
        port: "{{ email.smtp_port }}"
        sender: "{{ email.from_address }}"
        to: "{{ email.to_recipients }}"
        subject: "{{ email.subject }}"
        body: |
          IP: {{ ip_address | default('N/A') }}
          MAC: {{ target_mac | default('N/A') }}
          Location: {{ device_location }}
          {% set access_ports = groups['network_devices'] | map('extract', hostvars, 'device_data') | select('defined') | flatten | selectattr('port_type', 'equalto', 'access') | list %}
          Summary: {% if access_ports | length == 1 %}
          Port restart attempted on device: {{ access_ports[0].hostname }}, port: {{ access_ports[0].port }}.
          {% set config_result = (hostvars[access_ports[0].hostname].config_results | default([]) | selectattr('hostname', 'equalto', access_ports[0].hostname) | first | default({})).result | default({}) %}
          {% if config_result.get('failed', False) %}
          Configuration failed: {{ config_result.get('msg', 'Unknown error') }}
          {% elif not config_result.changed %}
          Port restart was not applied.
          {% endif %}
          {% else %}
          {% set found_ports = groups['network_devices'] | map('extract', hostvars, 'device_data') | select('defined') | flatten | selectattr('port', 'ne', 'Not found') | list %}
          {% if found_ports | length == 0 %}
          Port not found on all devices.
          {% else %}
          No single access port found ({{ access_ports | length }} access ports found).
          {% endif %}
          {% endif %}

          {% for device in groups['network_devices'] %}
          {% set dev_data = hostvars[device].device_data | default([]) | selectattr('hostname', 'equalto', device) | first | default({}) %}
          {% if dev_data.port | default('Not found') == 'Not found' %}
          Device: {{ device }}
          IP: {{ ip_address | default('N/A') }}
          MAC Address: {{ target_mac | default('N/A') }}
          Note: Port not found on this device.
          {% else %}
          Device: {{ device }}
          Location: {{ device_location }}
          MAC Address: {{ target_mac | default('N/A') }}
          Port: {{ dev_data.port | default('Not found') }}
          Port Type: {{ dev_data.port_type | default('unknown') }}
          {% set config_result = (hostvars[device].config_results | default([]) | selectattr('hostname', 'equalto', device) | first | default({})).result | default({}) %}
          Note: {% if dev_data.port_type | default('unknown') == 'access' %}
          Access port by IP / MAC located in this port{% if access_ports | length == 1 and device == access_ports[0].hostname and config_result.changed and not config_result.get('failed', False) %} and port restarted{% else %} and port no restart
          {% endif %}
          {% if config_result.get('failed', False) %}
          Configuration failed: {{ config_result.get('msg', 'Unknown error') }}
          {% endif %}
          {% else %}
          Port is not an access port; no restart applied.
          {% endif %}
          {% endif %}
          {% endfor %}
      run_once: true
      delegate_to: localhost
      when: template_mode == 'template2'

    - name: Display MAC and port for IP
      ansible.builtin.debug:
        msg: "MAC address {{ target_mac }} for IP {{ ip_address }} at location {{ device_location }} is on port {{ found_port | default('Not found') }}"
      when: target_mac != 'Not found' and (mac_line | default([]) | length > 0 or arp_port is defined)

    - name: No MAC or port found
      ansible.builtin.debug:
        msg: "No MAC or port found for IP {{ ip_address }} on this device at location {{ device_location }}"
      when: target_mac == 'Not found' or (mac_line | default([]) | length == 0 and arp_port is not defined)